# 业务场景灵活性架构设计 V0.7

## 🎯 核心设计原则

### 原则0: 不要改变现有问答逻辑如果需要修改，需要和用户确认

### 原则1：充分依赖模型规划能力
- **智能推荐由模型完成**：不是代码匹配，而是让模型根据用户输入自主选择和组合场景
- **减少硬编码逻辑**：代码只做场景管理和组合，不做智能判断
- **模型驱动决策**：模型决定使用哪些场景、如何组合

### 原则2：完整的默认配置体系
- **零配置可用**：用户不配置任何场景也能正常使用
- **默认系统提示**：基础能力定义（固定）
- **默认场景**：通用场景，不限制能力边界
- **默认推荐策略**：模型自主选择和组合场景

### 原则3：渐进式配置
- **基础层（默认）**：系统默认配置，所有用户可用
- **场景层（可选）**：用户可选择启用特定场景，系统需要给分配
- **用户层（自定义）**：用户可自定义prompt和规则
- **会话层（临时）**：会话级临时调整

### 原则4：自我进化能力
- **用户反馈学习**：收集用户对回答的满意度反馈
- **偏好学习**：从用户行为中学习习惯和偏好
- **提示词进化**：将用户偏好融入prompt，让系统更懂用户
- **分级学习**：用户级别（长期偏好）+ Session级别（临时偏好）

---

## 🏗️ 分层架构设计（明确版）

### 架构层次

```
┌─────────────────────────────────────────────────────────────┐
│  Layer 0: 系统默认层（System Default Layer）                  │
│  - 默认系统提示（基础能力定义）                                │
│  - 默认场景（通用场景，不限制能力）                            │
│  - 默认推荐策略（模型自主选择）                                │
│  - 所有可用工具列表（但不强制使用）                            │
│  特点：零配置可用，用户无需任何配置                            │
└─────────────────────────────────────────────────────────────┘
                           ↓ (可选)
┌─────────────────────────────────────────────────────────────┐
│  Layer 1: 场景层（Scenario Layer）- 可选                      │
│  - 用户选择的场景列表（可多选）                                │
│  - 场景prompt组合                                            │
│  - 场景兼容性检查                                            │
│  特点：用户可选择启用，不选择则使用默认场景                    │
└─────────────────────────────────────────────────────────────┘
                           ↓ (可选)
┌─────────────────────────────────────────────────────────────┐
│  Layer 2: 用户层（User Layer）- 可选                          │
│  - 用户自定义prompt                                          │
│  - 公司业务规则                                              │
│  - 个性化偏好                                                │
│  特点：用户可自定义，不配置则使用默认                          │
└─────────────────────────────────────────────────────────────┘
                           ↓ (可选)
┌─────────────────────────────────────────────────────────────┐
│  Layer 3: 会话层（Session Layer）- 可选                       │
│  - 会话级场景选择（覆盖用户配置）                              │
│  - 临时prompt调整                                            │
│  - 会话上下文                                                │
│  特点：仅影响当前会话，不配置则继承用户/默认配置              │
└─────────────────────────────────────────────────────────────┘
                           ↓ (自动学习)
┌─────────────────────────────────────────────────────────────┐
│  Layer 4: 进化层（Evolution Layer）- 自动                    │
│  - 用户级别偏好（跨会话的长期偏好）                            │
│    • 常用场景偏好                                             │
│    • 回答风格偏好                                             │
│    • 反馈总结和学习                                           │
│  - Session级别偏好（当前会话的临时偏好）                       │
│    • 会话中的反馈和调整                                       │
│    • 会话上下文偏好                                           │
│  特点：自动从用户反馈和行为中学习，动态融入prompt              │
└─────────────────────────────────────────────────────────────┘
```

---

## 📋 需求明确

### 需求1：默认配置体系（必须）

#### 1.1 默认系统提示（System Default Prompt）
**位置**：`backend/services/agent_service.py` 或数据库全局配置

**内容**：
- 基础能力定义（工具使用、行为规范等）
- 通用原则（不做能力限制）
- 让模型自主规划和选择能力

**特点**：
- ✅ 所有用户共享
- ✅ 系统管理员可配置
- ✅ 向后兼容现有系统

#### 1.2 默认场景（Default Scenario）
**定义**：通用场景，不限制模型能力边界

**特点**：
- ✅ 不限制工具使用
- ✅ 不限制能力范围
- ✅ 让模型自主判断和规划
- ✅ 零配置可用

**实现方式**：
```python
DEFAULT_SCENARIO = {
    "scenario_id": "default",
    "name": "通用场景",
    "description": "不限制能力的通用场景，让模型自主规划",
    "system_prompt": "",  # 空或极简，主要依赖系统默认prompt
    "allowed_tools": None,  # None表示不限制
    "recommended_model": None,
    "is_default": True
}
```

#### 1.3 默认推荐策略（Default Recommendation Strategy）
**策略**：模型自主选择和组合场景

**实现方式**：
- **方案A（推荐）**：在系统prompt中告诉模型可用场景，让模型自主选择
- **方案B**：每次请求时，模型根据用户输入和可用场景自主选择
- **方案C**：模型自主规划，不依赖预定义场景

**核心思想**：
- ❌ 不使用代码匹配关键词
- ❌ 不使用语义相似度计算
- ✅ 让模型根据用户输入自主判断
- ✅ 代码只提供场景列表和组合能力

---

### 需求2：模型驱动的智能推荐（必须）

#### 2.1 推荐方式：模型自主选择

**实现思路**：
1. **系统prompt中告知模型可用场景**
   ```
   可用场景列表：
   - 数据分析：专注于数据分析和可视化
   - DeepResearch：深度研究和信息收集
   - 文本审校：文本校对和优化
   - ...
   
   你可以根据用户需求自主选择和组合使用这些场景，或使用通用能力。
   ```

2. **模型在响应中自主选择场景**
   - 模型根据用户输入判断需要哪些场景能力
   - 模型可以组合多个场景
   - 模型可以只使用通用能力（不选择任何场景）

3. **代码只做场景管理和组合**
   - 提供场景列表给模型
   - 组合模型选择的场景prompt
   - 不参与智能判断

#### 2.2 场景选择流程

```
用户输入
    ↓
系统prompt（包含可用场景列表）
    ↓
模型自主判断：需要哪些场景能力？
    ↓
模型选择场景（或选择通用能力）
    ↓
代码组合场景prompt
    ↓
执行任务
```

**关键点**：
- 模型在思考过程中决定使用哪些场景
- 代码只负责提供场景列表和组合prompt
- 不限制模型的能力边界

---

### 需求3：场景组合机制（必须）

#### 3.1 组合策略

**默认策略：合并模式（merge）**
- 多个场景的prompt合并
- 模型自主协调不同场景的能力
- 代码不做冲突检测（交给模型处理）

#### 3.2 组合实现

```python
def combine_scenario_prompts(scenarios: List[Scenario]) -> str:
    """
    组合多个场景prompt
    
    策略：简单合并，让模型自主协调
    """
    if not scenarios:
        return ""  # 使用默认场景
    
    prompts = [s.system_prompt for s in scenarios if s.system_prompt]
    return "\n\n".join([
        f"## 场景能力 {i+1}: {scenarios[i].name}\n{prompts[i]}"
        for i in range(len(prompts))
    ])
```

---

### 需求4：配置层级和优先级

#### 4.1 配置层级

| 层级 | 配置位置 | 优先级 | 是否必须 |
|------|---------|--------|---------|
| Layer 0: 系统默认 | 系统配置/数据库 | 最低 | ✅ 必须 |
| Layer 1: 场景层 | 用户配置 | 中 | ❌ 可选 |
| Layer 2: 用户层 | 用户自定义prompt | 中高 | ❌ 可选 |
| Layer 3: 会话层 | 会话配置 | 最高 | ❌ 可选 |

#### 4.2 配置合并规则

```python
def compose_final_prompt(
    system_default: str,
    user_scenarios: Optional[List[Scenario]] = None,
    user_custom_prompt: Optional[str] = None,
    session_scenarios: Optional[List[Scenario]] = None,
    session_custom_prompt: Optional[str] = None
) -> str:
    """
    组合最终prompt
    
    优先级：会话层 > 用户层 > 场景层 > 系统默认层
    """
    # 1. 系统默认（必须有）
    parts = [system_default]
    
    # 2. 场景层（会话层优先，否则用户层，否则默认场景）
    scenarios = session_scenarios or user_scenarios or [DEFAULT_SCENARIO]
    if scenarios:
        scenario_prompt = combine_scenario_prompts(scenarios)
        if scenario_prompt:
            parts.append(scenario_prompt)
    
    # 3. 用户层（会话层优先，否则用户层）
    custom_prompt = session_custom_prompt or user_custom_prompt
    if custom_prompt:
        parts.append(f"\n## 用户自定义规则\n{custom_prompt}")
    
    return "\n\n".join(parts)
```

---

## 🔧 技术实现方案

### 实现1：默认配置管理

#### 1.1 默认系统提示

```python
# backend/services/default_config.py

class DefaultConfig:
    """默认配置管理"""
    
    DEFAULT_SYSTEM_PROMPT = """
你是一个强大的AI助手，具备自主规划和执行任务的能力。

## 核心能力
- 任务理解：仔细理解用户需求
- 自主规划：根据任务复杂度决定是否需要分解步骤
- 工具使用：根据需要选择合适的工具
- 自我检查：持续验证结果，发现错误及时调整

## 可用场景能力
你可以根据用户需求自主选择和组合使用以下场景能力，或直接使用通用能力：

{available_scenarios_list}

## 使用原则
- 根据用户需求自主判断需要哪些场景能力
- 可以组合多个场景能力
- 如果用户需求不匹配任何场景，使用通用能力即可
- 灵活应对，不限制自己的能力边界

使用ReAct范式（推理-行动-观察-反思）循环执行任务，确保准确完成用户目标。
"""
    
    DEFAULT_SCENARIO = {
        "scenario_id": "default",
        "name": "通用场景",
        "description": "不限制能力的通用场景",
        "system_prompt": "",  # 空，主要依赖系统默认prompt
        "allowed_tools": None,  # None表示不限制
        "is_default": True
    }
    
    @classmethod
    def get_default_system_prompt(cls, available_scenarios: List[dict]) -> str:
        """获取默认系统提示"""
        scenarios_list = "\n".join([
            f"- {s['name']}: {s['description']}"
            for s in available_scenarios
        ])
        return cls.DEFAULT_SYSTEM_PROMPT.format(
            available_scenarios_list=scenarios_list
        )
```

#### 1.2 场景列表提供

```python
# backend/services/scenario_provider.py

class ScenarioProvider:
    """场景提供器"""
    
    async def get_available_scenarios(self, user_id: Optional[int] = None) -> List[Scenario]:
        """
        获取用户可用的场景列表
        
        包括：
        1. 公开场景
        2. 用户创建的私有场景
        3. 默认场景
        """
        scenarios = []
        
        # 1. 默认场景（必须）
        scenarios.append(ScenarioProvider.get_default_scenario())
        
        # 2. 公开场景
        public_scenarios = await self.db.get_public_scenarios()
        scenarios.extend(public_scenarios)
        
        # 3. 用户私有场景
        if user_id:
            user_scenarios = await self.db.get_user_scenarios(user_id)
            scenarios.extend(user_scenarios)
        
        return scenarios
```

---

### 实现2：模型驱动的场景选择

#### 2.1 系统prompt中提供场景信息

```python
# backend/services/prompt_composer.py

class PromptComposer:
    """Prompt组合器"""
    
    async def compose_prompt(
        self,
        user_id: Optional[int] = None,
        session_id: Optional[str] = None,
        user_scenario_ids: Optional[List[str]] = None,  # 用户选择的场景
        session_scenario_ids: Optional[List[str]] = None,  # 会话级场景
        user_custom_prompt: Optional[str] = None,
        session_custom_prompt: Optional[str] = None
    ) -> str:
        """
        组合最终prompt
        
        关键：系统prompt中包含可用场景列表，让模型自主选择
        """
        # 1. 获取可用场景列表
        scenario_provider = ScenarioProvider(self.db)
        available_scenarios = await scenario_provider.get_available_scenarios(user_id)
        
        # 2. 构建系统默认prompt（包含场景列表）
        system_prompt = DefaultConfig.get_default_system_prompt(
            [s.to_dict() for s in available_scenarios]
        )
        
        # 3. 确定使用的场景（优先级：会话层 > 用户层 > 默认）
        final_scenarios = self._determine_scenarios(
            session_scenario_ids,
            user_scenario_ids,
            available_scenarios
        )
        
        # 4. 组合场景prompt（如果用户/会话指定了场景）
        scenario_prompt = ""
        if final_scenarios and final_scenarios != [DefaultConfig.DEFAULT_SCENARIO]:
            scenario_prompt = self._combine_scenarios(final_scenarios)
        
        # 5. 用户自定义prompt
        custom_prompt = session_custom_prompt or user_custom_prompt
        
        # 6. 组合最终prompt
        parts = [system_prompt]
        if scenario_prompt:
            parts.append(scenario_prompt)
        if custom_prompt:
            parts.append(f"\n## 用户自定义规则\n{custom_prompt}")
        
        return "\n\n".join(parts)
    
    def _determine_scenarios(
        self,
        session_scenario_ids: Optional[List[str]],
        user_scenario_ids: Optional[List[str]],
        available_scenarios: List[Scenario]
    ) -> List[Scenario]:
        """确定使用的场景"""
        # 优先级：会话层 > 用户层 > 默认
        scenario_ids = session_scenario_ids or user_scenario_ids
        
        if not scenario_ids:
            # 使用默认场景（模型自主选择）
            return [DefaultConfig.DEFAULT_SCENARIO]
        
        # 查找对应的场景对象
        scenarios = [
            s for s in available_scenarios
            if s.scenario_id in scenario_ids
        ]
        
        return scenarios if scenarios else [DefaultConfig.DEFAULT_SCENARIO]
    
    def _combine_scenarios(self, scenarios: List[Scenario]) -> str:
        """组合场景prompt（简单合并）"""
        prompts = []
        for i, scenario in enumerate(scenarios):
            if scenario.system_prompt:
                prompts.append(
                    f"### 场景能力 {i+1}: {scenario.name}\n{scenario.system_prompt}"
                )
        return "\n\n".join(prompts)
```

---

### 实现3：数据库设计

#### 3.1 用户配置表（调整）

```sql
-- 用户场景配置（支持多选）
CREATE TABLE user_scenario_configs (
    user_id INTEGER NOT NULL PRIMARY KEY,
    scenario_ids TEXT,  -- JSON数组，NULL表示使用默认（模型自主选择）
    user_custom_prompt TEXT,  -- 用户自定义prompt
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES users(id)
);

-- 会话场景配置（会话级覆盖）
CREATE TABLE session_scenario_configs (
    session_id TEXT NOT NULL PRIMARY KEY,
    scenario_ids TEXT,  -- JSON数组，NULL表示使用用户配置或默认
    session_custom_prompt TEXT,  -- 会话级自定义prompt
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (session_id) REFERENCES sessions(session_id)
);
```

#### 3.2 默认配置表（新增）

```sql
-- 系统默认配置表
CREATE TABLE system_default_config (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    config_key TEXT UNIQUE NOT NULL,
    config_value TEXT NOT NULL,
    description TEXT,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 插入默认配置
INSERT INTO system_default_config (config_key, config_value, description) VALUES
('default_system_prompt', '...', '默认系统提示'),
('default_scenario_id', 'default', '默认场景ID');
```

---

## 🔄 自我进化机制设计

### 核心思想

**系统要成为最懂用户的AI助手**
- 从用户反馈中学习
- 从用户行为中学习偏好
- 将学习结果融入prompt，让模型更懂用户
- 用户级别（长期）+ Session级别（短期）

### 进化数据来源

#### 1. 用户反馈（推荐方式）
- **显式反馈**：
  - 👍 点赞：回答有用
  - 👎 点踩：回答无用（可选：简单原因选择）
  - ✏️ 纠正：用户提供正确内容
  - 🔄 重新生成：用户不满意，要求重新回答
- **隐式反馈**：
  - 用户重新提问（可能表示不满意）
  - 用户修改问题（可能表示理解偏差）
  - 用户切换场景（可能表示场景不匹配）
  - 用户快速跳过回答（可能表示不相关）

#### 2. 用户行为（智能分析）
- **场景使用模式**：让模型分析用户最常用的场景组合
- **问题类型模式**：让模型总结用户常问的问题类型
- **回答风格偏好**：让模型从反馈中推断用户偏好（详细/简洁/专业/轻松）
- **工具使用模式**：让模型分析用户偏好的工具组合

#### 3. 用户习惯（模型总结）
- **工作模式**：让模型从对话历史中总结用户的工作模式
- **任务流程**：让模型识别用户的典型任务流程
- **语言风格**：让模型从对话中学习用户的语言风格偏好

### 数据分级

#### 用户级别偏好（User-Level Preferences）
**特点**：
- 跨会话的长期偏好
- 需要累积一定数据量才生效
- 相对稳定，变化较慢
- 影响所有新会话

**收集方式**：
- 统计分析用户历史行为
- 汇总用户反馈
- 识别用户模式

**存储位置**：
- `user_preferences` 表
- 定期更新（如每天或每周）

#### Session级别偏好（Session-Level Preferences）
**特点**：
- 当前会话的临时偏好
- 实时学习和调整
- 变化较快
- 仅影响当前会话

**收集方式**：
- 会话中的实时反馈
- 会话上下文分析
- 会话中的纠正和调整

**存储位置**：
- `session_preferences` 表
- 会话结束时可选择性保存到用户级别

---

### 实现方案

#### 1. 反馈收集机制

```python
# backend/services/feedback_collector.py

class FeedbackCollector:
    """反馈收集器"""
    
    async def collect_feedback(
        self,
        user_id: int,
        session_id: str,
        message_id: str,
        feedback_type: str,  # 'like' | 'dislike' | 'correct' | 'regenerate'
        feedback_data: Optional[dict] = None
    ):
        """
        收集用户反馈
        
        Args:
            user_id: 用户ID
            session_id: 会话ID
            message_id: 消息ID
            feedback_type: 反馈类型
            feedback_data: 反馈数据（如纠正内容）
        """
        # 保存反馈记录
        await self.db.save_feedback({
            'user_id': user_id,
            'session_id': session_id,
            'message_id': message_id,
            'feedback_type': feedback_type,
            'feedback_data': feedback_data,
            'timestamp': datetime.utcnow()
        })
        
        # 实时更新session级别偏好
        await self._update_session_preferences(
            session_id, feedback_type, feedback_data
        )
        
        # 异步更新用户级别偏好（批量处理）
        await self._queue_user_preference_update(user_id)
```

#### 2. 智能偏好学习引擎（模型驱动）

```python
# backend/services/preference_learner.py

class PreferenceLearner:
    """智能偏好学习引擎 - 使用模型智能提取"""
    
    async def learn_user_preferences(
        self, 
        user_id: int,
        agent_service: AgentService
    ) -> UserPreferences:
        """
        使用模型智能提取用户偏好
        
        核心思想：不加载所有数据，只加载关键摘要，让模型智能分析
        
        Args:
            user_id: 用户ID
            agent_service: Agent服务（用于调用模型）
            
        Returns:
            UserPreferences: 用户偏好对象
        """
        # 1. 获取关键数据摘要（不加载所有数据）
        summary = await self._get_user_data_summary(user_id)
        
        # 2. 使用模型智能提取偏好
        preferences = await self._extract_preferences_with_model(
            summary, agent_service
        )
        
        return preferences
    
    async def _get_user_data_summary(self, user_id: int) -> dict:
        """
        获取用户数据摘要（只加载关键信息，不是所有数据）
        
        只加载：
        - 最近N条反馈（如最近50条）
        - 场景使用统计（聚合数据）
        - 最近N个问题类型（如最近100个问题的类型）
        - 反馈关键词（从反馈中提取的关键词）
        """
        return {
            'recent_feedback': await self.db.get_recent_feedback(user_id, limit=50),
            'scenario_stats': await self.db.get_scenario_usage_stats(user_id),
            'question_types': await self.db.get_recent_question_types(user_id, limit=100),
            'feedback_keywords': await self.db.get_feedback_keywords(user_id),
            'total_sessions': await self.db.get_user_session_count(user_id),
            'total_messages': await self.db.get_user_message_count(user_id)
        }
    
    async def _extract_preferences_with_model(
        self,
        summary: dict,
        agent_service: AgentService
    ) -> UserPreferences:
        """
        使用模型智能提取用户偏好
        
        让模型分析数据摘要，提取偏好和规则
        """
        # 构建分析prompt
        analysis_prompt = f"""
请分析以下用户数据，提取用户的偏好和习惯：

## 用户数据摘要

### 反馈数据（最近50条）
{self._format_feedback(summary['recent_feedback'])}

### 场景使用统计
{self._format_scenario_stats(summary['scenario_stats'])}

### 问题类型
{self._format_question_types(summary['question_types'])}

### 反馈关键词
{summary['feedback_keywords']}

## 分析任务

请从以上数据中提取：
1. **常用场景偏好**：用户最常用哪些场景？为什么？
2. **回答风格偏好**：用户偏好详细回答还是简洁回答？专业风格还是轻松风格？
3. **问题类型模式**：用户经常问什么类型的问题？
4. **从反馈中学习的规则**：从用户的反馈和纠正中，总结出哪些规则？（如：用户不喜欢过于详细的技术细节、用户偏好用图表展示数据等）
5. **工作模式**：用户的工作模式是什么？（如：经常做数据分析、经常做文本审校等）

请以JSON格式返回分析结果：
{{
    "preferred_scenarios": ["场景1", "场景2"],
    "preferred_style": "detailed|concise|professional|casual",
    "common_question_types": ["类型1", "类型2"],
    "learned_rules": ["规则1", "规则2"],
    "work_pattern": "工作模式描述",
    "reasoning": "分析推理过程"
}}
"""
        
        # 调用模型分析
        response = await agent_service.query_once(
            prompt=analysis_prompt,
            model="sonnet"  # 使用sonnet进行智能分析
        )
        
        # 解析模型返回的JSON
        preferences_data = json.loads(response.text)
        
        return UserPreferences(
            preferred_scenarios=preferences_data.get('preferred_scenarios', []),
            preferred_style=preferences_data.get('preferred_style', 'detailed'),
            common_question_types=preferences_data.get('common_question_types', []),
            learned_rules=preferences_data.get('learned_rules', []),
            work_pattern=preferences_data.get('work_pattern', ''),
            reasoning=preferences_data.get('reasoning', '')
        )
    
    async def get_user_preferences_cached(
        self,
        user_id: int,
        agent_service: AgentService
    ) -> Optional[UserPreferences]:
        """
        获取用户偏好（带缓存）
        
        核心：检查缓存，如果数据摘要没变化，直接返回缓存结果
        """
        # 1. 获取数据摘要
        summary = await self._get_user_data_summary(user_id)
        summary_hash = self._hash_summary(summary)
        
        # 2. 检查缓存
        cached = await self.db.get_user_preferences_cache(user_id)
        if cached and cached.data_summary_hash == summary_hash:
            # 数据没变化，直接返回缓存
            return UserPreferences.from_json(cached.preferences_data)
        
        # 3. 数据有变化，使用模型重新分析
        preferences = await self.learn_user_preferences(user_id, agent_service)
        
        # 4. 更新缓存
        await self.db.save_user_preferences_cache(
            user_id,
            preferences.to_json(),
            summary_hash
        )
        
        return preferences
    
    def _hash_summary(self, summary: dict) -> str:
        """生成数据摘要的hash"""
        import hashlib
        import json
        summary_str = json.dumps(summary, sort_keys=True)
        return hashlib.md5(summary_str.encode()).hexdigest()
    
    async def learn_session_preferences(
        self,
        session_id: str,
        agent_service: AgentService
    ) -> SessionPreferences:
        """
        使用模型智能学习会话级别偏好
        
        Args:
            session_id: 会话ID
            agent_service: Agent服务
            
        Returns:
            SessionPreferences: 会话偏好对象
        """
        # 只加载关键数据（不加载所有消息）
        session_summary = await self._get_session_summary(session_id)
        
        # 使用模型提取会话偏好
        preferences = await self._extract_session_preferences_with_model(
            session_summary, agent_service
        )
        
        return preferences
    
    async def _get_session_summary(self, session_id: str) -> dict:
        """
        获取会话摘要（只加载关键信息）
        
        只加载：
        - 会话中的反馈
        - 最近N条消息（如最近20条）
        - 用户纠正的内容
        """
        return {
            'feedback': await self.db.get_session_feedback(session_id),
            'recent_messages': await self.db.get_recent_messages(session_id, limit=20),
            'corrections': await self.db.get_session_corrections(session_id)
        }
    
    async def _extract_session_preferences_with_model(
        self,
        summary: dict,
        agent_service: AgentService
    ) -> SessionPreferences:
        """
        使用模型提取会话偏好
        """
        analysis_prompt = f"""
请分析当前会话的数据，提取会话级别的偏好和上下文：

## 会话数据

### 反馈记录
{self._format_feedback(summary['feedback'])}

### 最近消息（最近20条）
{self._format_messages(summary['recent_messages'])}

### 用户纠正
{self._format_corrections(summary['corrections'])}

## 分析任务

请提取：
1. **会话中的纠正和反馈**：用户纠正了什么？对什么不满意？
2. **会话上下文偏好**：本次会话的上下文是什么？用户关注什么？

请以JSON格式返回：
{{
    "corrections": ["纠正1", "纠正2"],
    "context_preferences": "上下文偏好描述",
    "feedback_summary": "反馈总结"
}}
"""
        
        response = await agent_service.query_once(
            prompt=analysis_prompt,
            model="sonnet"
        )
        
        data = json.loads(response.text)
        
        return SessionPreferences(
            corrections=data.get('corrections', []),
            context_preferences=data.get('context_preferences', ''),
            feedback_summary=data.get('feedback_summary', '')
        )
```

#### 3. Prompt进化器

```python
# backend/services/prompt_evolver.py

class PromptEvolver:
    """Prompt进化器"""
    
    def evolve_prompt(
        self,
        base_prompt: str,
        user_preferences: Optional[UserPreferences] = None,
        session_preferences: Optional[SessionPreferences] = None
    ) -> str:
        """
        将用户偏好融入prompt
        
        Args:
            base_prompt: 基础prompt
            user_preferences: 用户级别偏好
            session_preferences: Session级别偏好
            
        Returns:
            str: 进化后的prompt
        """
        evolution_parts = []
        
        # 用户级别偏好
        if user_preferences:
            user_evolution = self._build_user_evolution_prompt(user_preferences)
            if user_evolution:
                evolution_parts.append(user_evolution)
        
        # Session级别偏好
        if session_preferences:
            session_evolution = self._build_session_evolution_prompt(session_preferences)
            if session_evolution:
                evolution_parts.append(session_evolution)
        
        # 组合最终prompt
        if evolution_parts:
            evolution_section = "\n\n".join(evolution_parts)
            return f"{base_prompt}\n\n## 用户偏好和习惯\n{evolution_section}"
        
        return base_prompt
    
    def _build_user_evolution_prompt(
        self, 
        preferences: UserPreferences
    ) -> str:
        """构建用户级别进化prompt"""
        parts = []
        
        # 常用场景偏好
        if preferences.preferred_scenarios:
            scenarios_text = "、".join(preferences.preferred_scenarios)
            parts.append(f"- 用户经常使用以下场景：{scenarios_text}，可以优先考虑这些场景的能力")
        
        # 回答风格偏好
        if preferences.preferred_style:
            style_map = {
                'detailed': '详细、深入的回答',
                'concise': '简洁、精炼的回答',
                'professional': '专业、正式的风格',
                'casual': '轻松、友好的风格'
            }
            parts.append(f"- 用户偏好{style_map.get(preferences.preferred_style, preferences.preferred_style)}的回答风格")
        
        # 从反馈中学习的规则
        if preferences.learned_rules:
            parts.append("- 根据用户反馈学习的规则：")
            for rule in preferences.learned_rules:
                parts.append(f"  • {rule}")
        
        return "\n".join(parts) if parts else ""
    
    def _build_session_evolution_prompt(
        self,
        preferences: SessionPreferences
    ) -> str:
        """
        构建Session级别进化prompt
        
        核心：只包含本次会话的关键信息，简洁明了
        """
        parts = []
        
        # 会话中的关键纠正（只取最近的3-5条）
        if preferences.corrections:
            recent_corrections = preferences.corrections[-5:]  # 只取最近5条
            parts.append("- 本次会话中的用户纠正：")
            for correction in recent_corrections:
                parts.append(f"  • {correction}")
        
        # 会话上下文偏好（简洁描述）
        if preferences.context_preferences:
            # 如果太长，截取关键部分
            context = preferences.context_preferences
            if len(context) > 200:
                context = context[:200] + "..."
            parts.append(f"- 本次会话上下文：{context}")
        
        # 反馈总结（如果有）
        if preferences.feedback_summary:
            parts.append(f"- 反馈总结：{preferences.feedback_summary}")
        
        return "\n".join(parts) if parts else ""
```

#### 4. 数据库设计

```sql
-- 用户反馈表
CREATE TABLE user_feedback (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    user_id INTEGER NOT NULL,
    session_id TEXT NOT NULL,
    message_id TEXT NOT NULL,
    conversation_turn_id TEXT,
    feedback_type TEXT NOT NULL,  -- 'like' | 'dislike' | 'correct' | 'regenerate'
    feedback_data TEXT,  -- JSON数据（如纠正内容）
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES users(id),
    FOREIGN KEY (session_id) REFERENCES sessions(session_id)
);

-- 用户偏好表
CREATE TABLE user_preferences (
    user_id INTEGER PRIMARY KEY,
    preferred_scenarios TEXT,  -- JSON数组
    preferred_style TEXT,  -- 'detailed' | 'concise' | 'professional' | 'casual'
    common_question_types TEXT,  -- JSON数组
    learned_rules TEXT,  -- JSON数组，从反馈中学习的规则
    feedback_summary TEXT,  -- JSON对象，反馈总结
    last_updated TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES users(id)
);

-- 会话偏好表
CREATE TABLE session_preferences (
    session_id TEXT PRIMARY KEY,
    corrections TEXT,  -- JSON数组，会话中的纠正
    context_preferences TEXT,  -- JSON对象，会话上下文偏好
    feedback_history TEXT,  -- JSON数组，反馈历史
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (session_id) REFERENCES sessions(session_id)
);

-- 用户行为统计表（用于分析）
CREATE TABLE user_behavior_stats (
    user_id INTEGER NOT NULL,
    stat_type TEXT NOT NULL,  -- 'scenario_usage' | 'question_type' | 'tool_usage'
    stat_key TEXT NOT NULL,  -- 统计项（如场景ID、问题类型）
    stat_value INTEGER DEFAULT 0,  -- 统计值（如使用次数）
    last_updated TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    PRIMARY KEY (user_id, stat_type, stat_key),
    FOREIGN KEY (user_id) REFERENCES users(id)
);
```

---

### Prompt组合流程（包含进化层）

```python
async def compose_evolved_prompt(
    user_id: int,
    session_id: str,
    base_config: BaseConfig
) -> str:
    """
    组合包含进化层的完整prompt
    
    流程：
    1. 基础prompt（系统默认 + 场景层 + 用户层 + 会话层）
    2. 加载用户级别偏好
    3. 加载Session级别偏好
    4. 进化prompt（融入偏好）
    """
    # 1. 组合基础prompt
    base_prompt = await compose_base_prompt(user_id, session_id, base_config)
    
    # 2. 加载偏好
    preference_learner = PreferenceLearner(db)
    user_preferences = await preference_learner.get_user_preferences(user_id)
    session_preferences = await preference_learner.get_session_preferences(session_id)
    
    # 3. 进化prompt
    prompt_evolver = PromptEvolver()
    evolved_prompt = prompt_evolver.evolve_prompt(
        base_prompt,
        user_preferences,
        session_preferences
    )
    
    return evolved_prompt
```

---

### 前端反馈收集

```typescript
// frontend/components/MessageFeedback.tsx

interface MessageFeedbackProps {
  messageId: string;
  onFeedback: (type: 'like' | 'dislike' | 'correct', data?: any) => void;
}

const MessageFeedback: React.FC<MessageFeedbackProps> = ({
  messageId,
  onFeedback
}) => {
  const handleLike = () => {
    onFeedback('like');
  };
  
  const handleDislike = () => {
    // 可以弹出反馈框，收集具体原因
    const reason = prompt('请告诉我们哪里需要改进？');
    onFeedback('dislike', { reason });
  };
  
  const handleCorrect = () => {
    // 用户可以输入纠正内容
    const correction = prompt('请提供正确的内容：');
    if (correction) {
      onFeedback('correct', { correction });
    }
  };
  
  return (
    <div className="message-feedback">
      <button onClick={handleLike}>👍 有用</button>
      <button onClick={handleDislike}>👎 无用</button>
      <button onClick={handleCorrect}>✏️ 纠正</button>
    </div>
  );
};
```

---

### 偏好更新策略（智能更新）

#### 用户级别偏好更新
- **触发时机**：
  - 用户反馈累积达到阈值（如10条新反馈）
  - 定时任务（如每天凌晨，使用模型批量分析）
  - 手动触发（管理员）
  
- **更新方式（推荐）**：
  - ✅ **使用模型智能分析**：只加载数据摘要，让模型提取偏好
  - ✅ **渐进式更新**：保留旧偏好权重，新偏好逐步融合
  - ✅ **缓存机制**：偏好结果缓存，减少模型调用
  - ❌ **不使用代码统计**：不写复杂的统计逻辑

#### Session级别偏好更新
- **触发时机**：
  - 用户反馈时实时更新（轻量级）
  - 会话结束时使用模型总结（完整分析）
  
- **更新方式（推荐）**：
  - ✅ **实时轻量更新**：只记录反馈，不立即分析
  - ✅ **会话结束时模型总结**：使用模型分析整个会话
  - ✅ **可选保存到用户级别**：会话结束时可选择是否保存到用户偏好

---

## ✅ 需求确认清单

### 必须实现（Phase 1）

- [ ] **默认系统提示**
  - [ ] 定义默认系统prompt模板
  - [ ] 支持在系统prompt中动态插入可用场景列表
  - [ ] 系统管理员可配置默认系统prompt

- [ ] **默认场景**
  - [ ] 定义默认场景（通用、不限制能力）
  - [ ] 默认场景ID: "default"
  - [ ] 不配置任何场景时使用默认场景

- [ ] **模型驱动的场景选择**
  - [ ] 系统prompt中包含可用场景列表
  - [ ] 模型自主判断和选择场景（不依赖代码匹配）
  - [ ] 代码只提供场景列表和组合能力

- [ ] **零配置可用**
  - [ ] 用户不配置任何场景也能正常使用
  - [ ] 使用默认系统prompt + 默认场景
  - [ ] 模型自主规划和执行

### 可选实现（Phase 2+）

- [ ] **自我进化机制（重要）**
  - [ ] 反馈收集机制（点赞/点踩/纠正）
  - [ ] 用户级别偏好学习
    - [ ] 场景使用频率分析
    - [ ] 反馈模式分析
    - [ ] 问题类型分析
    - [ ] 回答风格偏好分析
  - [ ] Session级别偏好学习
    - [ ] 会话反馈收集
    - [ ] 会话上下文分析
    - [ ] 实时偏好更新
  - [ ] Prompt进化器
    - [ ] 用户偏好融入prompt
    - [ ] Session偏好融入prompt
    - [ ] 进化prompt组合
  - [ ] 数据库设计
    - [ ] 用户反馈表
    - [ ] 用户偏好表
    - [ ] 会话偏好表
    - [ ] 用户行为统计表
  - [ ] 前端反馈UI
    - [ ] 消息反馈按钮
    - [ ] 反馈收集表单
    - [ ] 偏好设置界面

- [ ] **其他可选功能**

- [ ] **用户场景选择（多选）**
  - [ ] 用户可选择启用多个场景
  - [ ] 场景prompt组合（简单合并）

- [ ] **用户自定义prompt**
  - [ ] 用户可添加自定义规则
  - [ ] 与场景prompt合并

- [ ] **会话级配置**
  - [ ] 会话级场景选择
  - [ ] 会话级prompt调整

- [ ] **场景管理**
  - [ ] 场景创建和编辑
  - [ ] 场景分享和复用

---

## 🎯 核心设计要点总结

### 1. 默认配置是必须的
- ✅ 系统默认prompt（基础能力定义）
- ✅ 默认场景（通用、不限制能力）
- ✅ 零配置可用

### 2. 模型驱动，代码辅助
- ✅ 模型自主选择和组合场景
- ✅ 代码只提供场景列表和组合能力
- ❌ 不使用代码匹配和语义计算

### 3. 渐进式配置
- Layer 0（默认）：必须，零配置可用
- Layer 1-3（可选）：用户可选择性配置

### 4. 能力不限制
- ✅ 默认场景不限制工具和能力
- ✅ 让模型自主判断和规划
- ✅ 不预设能力边界

### 5. 自我进化能力
- ✅ 从用户反馈中学习
- ✅ 用户级别偏好（长期）
- ✅ Session级别偏好（短期）
- ✅ 自动融入prompt，让系统更懂用户

---

## 📊 下一步行动

### 确认需求
1. ✅ 默认配置体系设计
2. ✅ 模型驱动的场景选择方案
3. ✅ 零配置可用性
4. ✅ 配置层级和优先级

### 开始开发（Phase 1）
1. 实现默认配置管理
2. 实现Prompt组合器（支持默认配置）
3. 数据库schema调整
4. API接口调整
5. 前端场景选择器（支持多选和默认）

---

**请确认以上需求是否满足您的期望，确认后我们开始分阶段开发。**
